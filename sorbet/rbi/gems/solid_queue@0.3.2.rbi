# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `solid_queue` gem.
# Please instead update this file by running `bin/tapioca gem solid_queue`.


# source://solid_queue//lib/active_job/concurrency_controls.rb#3
module ActiveJob
  class << self
    # source://activejob/7.1.3.4/lib/active_job/queue_adapter.rb#7
    def adapter_name(adapter); end

    # source://activejob/7.1.3.4/lib/active_job/deprecator.rb#4
    def deprecator; end

    # source://activejob/7.1.3.4/lib/active_job/gem_version.rb#5
    def gem_version; end

    # source://activejob/7.1.3.4/lib/active_job/enqueuing.rb#16
    def perform_all_later(*jobs); end

    # source://activejob/7.1.3.4/lib/active_job.rb#53
    def use_big_decimal_serializer; end

    # source://activejob/7.1.3.4/lib/active_job.rb#53
    def use_big_decimal_serializer=(_arg0); end

    # source://activejob/7.1.3.4/lib/active_job.rb#61
    def verbose_enqueue_logs; end

    # source://activejob/7.1.3.4/lib/active_job.rb#61
    def verbose_enqueue_logs=(_arg0); end

    # source://activejob/7.1.3.4/lib/active_job/version.rb#7
    def version; end

    private

    # source://activejob/7.1.3.4/lib/active_job/instrumentation.rb#6
    def instrument_enqueue_all(queue_adapter, jobs); end
  end
end

class ActiveJob::Base
  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#963
  def _enqueue_callbacks; end

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#963
  def _perform_callbacks; end

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#951
  def _run_enqueue_callbacks(&block); end

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#951
  def _run_perform_callbacks(&block); end

  # source://activejob/7.1.3.4/lib/active_job/exceptions.rb#12
  def after_discard_procs; end

  # source://activejob/7.1.3.4/lib/active_job/exceptions.rb#12
  def after_discard_procs=(_arg0); end

  # source://activejob/7.1.3.4/lib/active_job/exceptions.rb#12
  def after_discard_procs?; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def blocked_by; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def blocked_by=(_arg0); end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def blocked_until; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def blocked_until=(_arg0); end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#14
  def concurrency_duration; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#14
  def concurrency_duration=(_arg0); end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#14
  def concurrency_duration?; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#13
  def concurrency_limit; end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#13
  def concurrency_limit=(_arg0); end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#13
  def concurrency_limit?; end

  # source://activesupport/7.1.3.4/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def current_queue_adapter; end

  # source://activesupport/7.1.3.4/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def current_queue_adapter=(obj); end

  # source://mission_control-jobs/0.2.1/lib/active_job/querying.rb#7
  def default_page_size; end

  # source://mission_control-jobs/0.2.1/lib/active_job/querying.rb#7
  def default_page_size=(_arg0); end

  # source://mission_control-jobs/0.2.1/lib/active_job/querying.rb#7
  def default_page_size?; end

  # source://mission_control-jobs/0.2.1/lib/active_job/failed.rb#5
  def failed_at; end

  # source://mission_control-jobs/0.2.1/lib/active_job/failed.rb#5
  def failed_at=(_arg0); end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def finished_at; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def finished_at=(_arg0); end

  # source://mission_control-jobs/0.2.1/lib/active_job/failed.rb#5
  def last_execution_error; end

  # source://mission_control-jobs/0.2.1/lib/active_job/failed.rb#5
  def last_execution_error=(_arg0); end

  # source://activejob/7.1.3.4/lib/active_job/logging.rb#11
  def logger; end

  # source://activejob/7.1.3.4/lib/active_job/logging.rb#11
  def logger=(val); end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def position; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def position=(_arg0); end

  # source://activejob/7.1.3.4/lib/active_job/queue_adapter.rb#26
  def queue_adapter(&block); end

  # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#57
  def queue_name_prefix; end

  # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#57
  def queue_name_prefix=(_arg0); end

  # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#57
  def queue_name_prefix?; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def raw_data; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def raw_data=(_arg0); end

  # source://activesupport/7.1.3.4/lib/active_support/rescuable.rb#15
  def rescue_handlers; end

  # source://activesupport/7.1.3.4/lib/active_support/rescuable.rb#15
  def rescue_handlers=(_arg0); end

  # source://activesupport/7.1.3.4/lib/active_support/rescuable.rb#15
  def rescue_handlers?; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#8
  def serialized_arguments; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def started_at; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def started_at=(_arg0); end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def status; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def status=(_arg0); end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def worker_id; end

  # source://mission_control-jobs/0.2.1/lib/active_job/executing.rb#7
  def worker_id=(_arg0); end

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#955
    def _enqueue_callbacks; end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#959
    def _enqueue_callbacks=(value); end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#955
    def _perform_callbacks; end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#959
    def _perform_callbacks=(value); end

    # source://activejob/7.1.3.4/lib/active_job/queue_adapter.rb#24
    def _queue_adapter; end

    # source://activejob/7.1.3.4/lib/active_job/queue_adapter.rb#24
    def _queue_adapter=(value); end

    # source://activejob/7.1.3.4/lib/active_job/queue_adapter.rb#23
    def _queue_adapter_name; end

    # source://activejob/7.1.3.4/lib/active_job/queue_adapter.rb#23
    def _queue_adapter_name=(value); end

    # source://activejob/7.1.3.4/lib/active_job/test_helper.rb#19
    def _test_adapter; end

    # source://activejob/7.1.3.4/lib/active_job/test_helper.rb#19
    def _test_adapter=(value); end

    # source://activejob/7.1.3.4/lib/active_job/exceptions.rb#12
    def after_discard_procs; end

    # source://activejob/7.1.3.4/lib/active_job/exceptions.rb#12
    def after_discard_procs=(value); end

    # source://activejob/7.1.3.4/lib/active_job/exceptions.rb#12
    def after_discard_procs?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#14
    def concurrency_duration; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#14
    def concurrency_duration=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#14
    def concurrency_duration?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#11
    def concurrency_group; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#11
    def concurrency_group=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#11
    def concurrency_group?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#10
    def concurrency_key; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#10
    def concurrency_key=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#10
    def concurrency_key?; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#13
    def concurrency_limit; end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#13
    def concurrency_limit=(value); end

    # source://solid_queue//lib/active_job/concurrency_controls.rb#13
    def concurrency_limit?; end

    # source://activesupport/7.1.3.4/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def current_queue_adapter; end

    # source://activesupport/7.1.3.4/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def current_queue_adapter=(obj); end

    # source://mission_control-jobs/0.2.1/lib/active_job/querying.rb#7
    def default_page_size; end

    # source://mission_control-jobs/0.2.1/lib/active_job/querying.rb#7
    def default_page_size=(value); end

    # source://mission_control-jobs/0.2.1/lib/active_job/querying.rb#7
    def default_page_size?; end

    # source://activejob/7.1.3.4/lib/active_job/logging.rb#12
    def log_arguments; end

    # source://activejob/7.1.3.4/lib/active_job/logging.rb#12
    def log_arguments=(value); end

    # source://activejob/7.1.3.4/lib/active_job/logging.rb#12
    def log_arguments?; end

    # source://activejob/7.1.3.4/lib/active_job/logging.rb#11
    def logger; end

    # source://activejob/7.1.3.4/lib/active_job/logging.rb#11
    def logger=(val); end

    # source://activejob/7.1.3.4/lib/active_job/queue_priority.rb#49
    def priority; end

    # source://activejob/7.1.3.4/lib/active_job/queue_priority.rb#49
    def priority=(value); end

    # source://activejob/7.1.3.4/lib/active_job/queue_priority.rb#49
    def priority?; end

    # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#55
    def queue_name; end

    # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#55
    def queue_name=(value); end

    # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#55
    def queue_name?; end

    # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#56
    def queue_name_delimiter; end

    # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#56
    def queue_name_delimiter=(value); end

    # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#56
    def queue_name_delimiter?; end

    # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#57
    def queue_name_prefix; end

    # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#57
    def queue_name_prefix=(value); end

    # source://activejob/7.1.3.4/lib/active_job/queue_name.rb#57
    def queue_name_prefix?; end

    # source://activesupport/7.1.3.4/lib/active_support/rescuable.rb#15
    def rescue_handlers; end

    # source://activesupport/7.1.3.4/lib/active_support/rescuable.rb#15
    def rescue_handlers=(value); end

    # source://activesupport/7.1.3.4/lib/active_support/rescuable.rb#15
    def rescue_handlers?; end

    # source://activejob/7.1.3.4/lib/active_job/exceptions.rb#11
    def retry_jitter; end

    # source://activejob/7.1.3.4/lib/active_job/exceptions.rb#11
    def retry_jitter=(value); end
  end
end

# source://solid_queue//lib/active_job/concurrency_controls.rb#4
module ActiveJob::ConcurrencyControls
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveJob::ConcurrencyControls::ClassMethods

  # source://solid_queue//lib/active_job/concurrency_controls.rb#26
  def concurrency_key; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/active_job/concurrency_controls.rb#39
  def concurrency_limited?; end

  private

  # source://solid_queue//lib/active_job/concurrency_controls.rb#48
  def compute_concurrency_parameter(option); end

  # source://solid_queue//lib/active_job/concurrency_controls.rb#44
  def concurrency_group; end

  module GeneratedClassMethods
    def concurrency_duration; end
    def concurrency_duration=(value); end
    def concurrency_duration?; end
    def concurrency_group; end
    def concurrency_group=(value); end
    def concurrency_group?; end
    def concurrency_key; end
    def concurrency_key=(value); end
    def concurrency_key?; end
    def concurrency_limit; end
    def concurrency_limit=(value); end
    def concurrency_limit?; end
  end

  module GeneratedInstanceMethods
    def concurrency_duration; end
    def concurrency_duration=(value); end
    def concurrency_duration?; end
    def concurrency_limit; end
    def concurrency_limit=(value); end
    def concurrency_limit?; end
  end
end

# source://solid_queue//lib/active_job/concurrency_controls.rb#0
module ActiveJob::ConcurrencyControls::ClassMethods
  # source://solid_queue//lib/active_job/concurrency_controls.rb#18
  def limits_concurrency(key:, to: T.unsafe(nil), group: T.unsafe(nil), duration: T.unsafe(nil)); end
end

# source://solid_queue//lib/active_job/concurrency_controls.rb#7
ActiveJob::ConcurrencyControls::DEFAULT_CONCURRENCY_GROUP = T.let(T.unsafe(nil), Proc)

# source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#4
module ActiveJob::QueueAdapters
  class << self
    # source://activejob/7.1.3.4/lib/active_job/queue_adapters.rb#137
    def lookup(name); end
  end
end

# == Active Job SolidQueue adapter
#
# To use it set the queue_adapter config to +:solid_queue+.
#
#   Rails.application.config.active_job.queue_adapter = :solid_queue
#
# source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#10
class ActiveJob::QueueAdapters::SolidQueueAdapter
  # source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#15
  def enqueue(active_job); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#11
  def enqueue_after_transaction_commit?; end

  # source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#23
  def enqueue_all(active_jobs); end

  # source://solid_queue//lib/active_job/queue_adapters/solid_queue_adapter.rb#19
  def enqueue_at(active_job, timestamp); end
end

# source://solid_queue//lib/solid_queue/version.rb#1
module SolidQueue
  extend ::SolidQueue

  # source://solid_queue//lib/solid_queue.rb#26
  def app_executor; end

  # source://solid_queue//lib/solid_queue.rb#26
  def app_executor=(val); end

  # source://solid_queue//lib/solid_queue.rb#43
  def clear_finished_jobs_after; end

  # source://solid_queue//lib/solid_queue.rb#43
  def clear_finished_jobs_after=(val); end

  # source://solid_queue//lib/solid_queue.rb#26
  def connects_to; end

  # source://solid_queue//lib/solid_queue.rb#26
  def connects_to=(val); end

  # source://solid_queue//lib/solid_queue.rb#44
  def default_concurrency_control_period; end

  # source://solid_queue//lib/solid_queue.rb#44
  def default_concurrency_control_period=(val); end

  # source://solid_queue//lib/solid_queue.rb#35
  def enqueue_after_transaction_commit; end

  # source://solid_queue//lib/solid_queue.rb#35
  def enqueue_after_transaction_commit=(val); end

  # source://solid_queue//lib/solid_queue.rb#58
  def instrument(channel, **options, &block); end

  # source://solid_queue//lib/solid_queue.rb#25
  def logger; end

  # source://solid_queue//lib/solid_queue.rb#25
  def logger=(val); end

  # source://solid_queue//lib/solid_queue.rb#26
  def on_thread_error; end

  # source://solid_queue//lib/solid_queue.rb#26
  def on_thread_error=(val); end

  # source://solid_queue//lib/solid_queue.rb#42
  def preserve_finished_jobs; end

  # source://solid_queue//lib/solid_queue.rb#42
  def preserve_finished_jobs=(val); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue.rb#54
  def preserve_finished_jobs?; end

  # source://solid_queue//lib/solid_queue.rb#31
  def process_alive_threshold; end

  # source://solid_queue//lib/solid_queue.rb#31
  def process_alive_threshold=(val); end

  # source://solid_queue//lib/solid_queue.rb#30
  def process_heartbeat_interval; end

  # source://solid_queue//lib/solid_queue.rb#30
  def process_heartbeat_interval=(val); end

  # source://solid_queue//lib/solid_queue.rb#33
  def shutdown_timeout; end

  # source://solid_queue//lib/solid_queue.rb#33
  def shutdown_timeout=(val); end

  # source://solid_queue//lib/solid_queue.rb#37
  def silence_polling; end

  # source://solid_queue//lib/solid_queue.rb#37
  def silence_polling=(val); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue.rb#50
  def silence_polling?; end

  # source://solid_queue//lib/solid_queue.rb#40
  def supervisor; end

  # source://solid_queue//lib/solid_queue.rb#40
  def supervisor=(val); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue.rb#46
  def supervisor?; end

  # source://solid_queue//lib/solid_queue.rb#39
  def supervisor_pidfile; end

  # source://solid_queue//lib/solid_queue.rb#39
  def supervisor_pidfile=(val); end

  # source://solid_queue//lib/solid_queue.rb#28
  def use_skip_locked; end

  # source://solid_queue//lib/solid_queue.rb#28
  def use_skip_locked=(val); end

  class << self
    # source://solid_queue//lib/solid_queue.rb#26
    def app_executor; end

    # source://solid_queue//lib/solid_queue.rb#26
    def app_executor=(val); end

    # source://solid_queue//lib/solid_queue.rb#43
    def clear_finished_jobs_after; end

    # source://solid_queue//lib/solid_queue.rb#43
    def clear_finished_jobs_after=(val); end

    # source://solid_queue//lib/solid_queue.rb#26
    def connects_to; end

    # source://solid_queue//lib/solid_queue.rb#26
    def connects_to=(val); end

    # source://solid_queue//lib/solid_queue.rb#44
    def default_concurrency_control_period; end

    # source://solid_queue//lib/solid_queue.rb#44
    def default_concurrency_control_period=(val); end

    # source://solid_queue//lib/solid_queue.rb#35
    def enqueue_after_transaction_commit; end

    # source://solid_queue//lib/solid_queue.rb#35
    def enqueue_after_transaction_commit=(val); end

    # source://solid_queue//lib/solid_queue.rb#25
    def logger; end

    # source://solid_queue//lib/solid_queue.rb#25
    def logger=(val); end

    # source://solid_queue//lib/solid_queue.rb#26
    def on_thread_error; end

    # source://solid_queue//lib/solid_queue.rb#26
    def on_thread_error=(val); end

    # source://solid_queue//lib/solid_queue.rb#42
    def preserve_finished_jobs; end

    # source://solid_queue//lib/solid_queue.rb#42
    def preserve_finished_jobs=(val); end

    # source://solid_queue//lib/solid_queue.rb#31
    def process_alive_threshold; end

    # source://solid_queue//lib/solid_queue.rb#31
    def process_alive_threshold=(val); end

    # source://solid_queue//lib/solid_queue.rb#30
    def process_heartbeat_interval; end

    # source://solid_queue//lib/solid_queue.rb#30
    def process_heartbeat_interval=(val); end

    # source://railties/7.1.3.4/lib/rails/engine.rb#412
    def railtie_helpers_paths; end

    # source://railties/7.1.3.4/lib/rails/engine.rb#395
    def railtie_namespace; end

    # source://railties/7.1.3.4/lib/rails/engine.rb#416
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end

    # source://solid_queue//lib/solid_queue.rb#33
    def shutdown_timeout; end

    # source://solid_queue//lib/solid_queue.rb#33
    def shutdown_timeout=(val); end

    # source://solid_queue//lib/solid_queue.rb#37
    def silence_polling; end

    # source://solid_queue//lib/solid_queue.rb#37
    def silence_polling=(val); end

    # source://solid_queue//lib/solid_queue.rb#40
    def supervisor; end

    # source://solid_queue//lib/solid_queue.rb#40
    def supervisor=(val); end

    # source://solid_queue//lib/solid_queue.rb#39
    def supervisor_pidfile; end

    # source://solid_queue//lib/solid_queue.rb#39
    def supervisor_pidfile=(val); end

    # source://railties/7.1.3.4/lib/rails/engine.rb#401
    def table_name_prefix; end

    # source://railties/7.1.3.4/lib/rails/engine.rb#408
    def use_relative_model_naming?; end

    # source://solid_queue//lib/solid_queue.rb#28
    def use_skip_locked; end

    # source://solid_queue//lib/solid_queue.rb#28
    def use_skip_locked=(val); end
  end
end

# source://solid_queue//lib/solid_queue/app_executor.rb#4
module SolidQueue::AppExecutor
  # source://solid_queue//lib/solid_queue/app_executor.rb#13
  def handle_thread_error(error); end

  # source://solid_queue//lib/solid_queue/app_executor.rb#5
  def wrap_in_app_executor(&block); end
end

class SolidQueue::BlockedExecution < ::SolidQueue::Execution
  include ::SolidQueue::BlockedExecution::GeneratedAttributeMethods
  include ::SolidQueue::BlockedExecution::GeneratedAssociationMethods

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_semaphore(*args); end

  def release; end

  private

  def acquire_concurrency_lock; end
  def promote_to_ready; end
  def ready_attributes; end
  def set_expires_at; end

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activerecord/7.1.3.4/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    def assumable_attributes_from_job; end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def expired(*args, **_arg1); end

    def release_many(concurrency_keys); end
    def release_one(concurrency_key); end
    def unblock(limit); end

    private

    def releasable(concurrency_keys); end
  end
end

module SolidQueue::BlockedExecution::GeneratedAssociationMethods
  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#32
  def build_semaphore(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_semaphore(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#40
  def create_semaphore!(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_semaphore; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#23
  def reset_semaphore; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def semaphore; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def semaphore=(value); end
end

module SolidQueue::BlockedExecution::GeneratedAttributeMethods; end

class SolidQueue::ClaimedExecution < ::SolidQueue::Execution
  include ::SolidQueue::ClaimedExecution::GeneratedAttributeMethods
  include ::SolidQueue::ClaimedExecution::GeneratedAssociationMethods

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_process(*args); end

  def discard; end
  def perform; end
  def release; end

  private

  def execute; end
  def failed_with(error); end
  def finished; end

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activerecord/7.1.3.4/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    def claiming(job_ids, process_id, &block); end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    def discard_all_from_jobs(*_arg0); end
    def discard_all_in_batches(*_arg0); end
    def release_all; end
  end
end

module SolidQueue::ClaimedExecution::GeneratedAssociationMethods
  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#32
  def build_process(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_process(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#40
  def create_process!(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def process; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def process=(value); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/belongs_to.rb#145
  def process_changed?; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/belongs_to.rb#149
  def process_previously_changed?; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_process; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#23
  def reset_process; end
end

module SolidQueue::ClaimedExecution::GeneratedAttributeMethods; end

class SolidQueue::ClaimedExecution::Result < ::Struct
  def success?; end
end

# source://solid_queue//lib/solid_queue/configuration.rb#4
class SolidQueue::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#20
  def initialize(mode: T.unsafe(nil), load_from: T.unsafe(nil)); end

  # source://solid_queue//lib/solid_queue/configuration.rb#45
  def dispatchers; end

  # source://solid_queue//lib/solid_queue/configuration.rb#55
  def max_number_of_threads; end

  # source://solid_queue//lib/solid_queue/configuration.rb#25
  def processes; end

  # source://solid_queue//lib/solid_queue/configuration.rb#34
  def workers; end

  private

  # source://solid_queue//lib/solid_queue/configuration.rb#65
  def config_from(file_or_hash, env: T.unsafe(nil)); end

  # source://solid_queue//lib/solid_queue/configuration.rb#75
  def dispatchers_options; end

  # source://solid_queue//lib/solid_queue/configuration.rb#86
  def load_config_from(file_or_hash); end

  # source://solid_queue//lib/solid_queue/configuration.rb#105
  def load_config_from_default_location; end

  # source://solid_queue//lib/solid_queue/configuration.rb#99
  def load_config_from_env_location; end

  # source://solid_queue//lib/solid_queue/configuration.rb#111
  def load_config_from_file(file); end

  # Returns the value of attribute mode.
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#61
  def mode; end

  # source://solid_queue//lib/solid_queue/configuration.rb#80
  def parse_recurring_tasks(tasks); end

  # Returns the value of attribute raw_config.
  #
  # source://solid_queue//lib/solid_queue/configuration.rb#61
  def raw_config; end

  # source://solid_queue//lib/solid_queue/configuration.rb#70
  def workers_options; end
end

# source://solid_queue//lib/solid_queue/configuration.rb#63
SolidQueue::Configuration::DEFAULT_CONFIG_FILE_PATH = T.let(T.unsafe(nil), String)

# source://solid_queue//lib/solid_queue/configuration.rb#12
SolidQueue::Configuration::DISPATCHER_DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://solid_queue//lib/solid_queue/configuration.rb#5
SolidQueue::Configuration::WORKER_DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://solid_queue//lib/solid_queue.rb#23
SolidQueue::DEFAULT_LOGGER = T.let(T.unsafe(nil), ActiveSupport::Logger)

# source://solid_queue//lib/solid_queue/dispatcher.rb#4
class SolidQueue::Dispatcher < ::SolidQueue::Processes::Base
  include ::SolidQueue::Processes::Supervised
  include ::SolidQueue::Processes::Runnable
  include ::SolidQueue::Processes::Poller

  # @return [Dispatcher] a new instance of Dispatcher
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#12
  def initialize(**options); end

  # Returns the value of attribute batch_size.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#7
  def batch_size; end

  # Sets the attribute batch_size
  #
  # @param value the value to set the attribute batch_size to.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#7
  def batch_size=(_arg0); end

  # Returns the value of attribute concurrency_maintenance.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#7
  def concurrency_maintenance; end

  # Sets the attribute concurrency_maintenance
  #
  # @param value the value to set the attribute concurrency_maintenance to.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#7
  def concurrency_maintenance=(_arg0); end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#22
  def metadata; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#10
  def polling_interval; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#10
  def polling_interval=(_arg0); end

  # Returns the value of attribute recurring_schedule.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#7
  def recurring_schedule; end

  # Sets the attribute recurring_schedule
  #
  # @param value the value to set the attribute recurring_schedule to.
  #
  # source://solid_queue//lib/solid_queue/dispatcher.rb#7
  def recurring_schedule=(_arg0); end

  private

  # source://solid_queue//lib/solid_queue/dispatcher.rb#32
  def dispatch_next_batch; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#42
  def load_recurring_schedule; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#27
  def poll; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#54
  def set_procline; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#38
  def start_concurrency_maintenance; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#46
  def stop_concurrency_maintenance; end

  # source://solid_queue//lib/solid_queue/dispatcher.rb#50
  def unload_recurring_schedule; end

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end
  end
end

# source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#4
class SolidQueue::Dispatcher::ConcurrencyMaintenance
  include ::SolidQueue::AppExecutor

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#9
  def initialize(interval, batch_size); end

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#7
  def batch_size; end

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#7
  def interval; end

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#14
  def start; end

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#27
  def stop; end

  private

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#32
  def expire_semaphores; end

  # source://solid_queue//lib/solid_queue/dispatcher/concurrency_maintenance.rb#38
  def unblock_blocked_executions; end
end

# source://solid_queue//lib/solid_queue/dispatcher/recurring_schedule.rb#4
class SolidQueue::Dispatcher::RecurringSchedule
  include ::SolidQueue::AppExecutor

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_schedule.rb#9
  def initialize(tasks); end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_schedule.rb#7
  def configured_tasks; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_schedule.rb#33
  def inspect; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_schedule.rb#20
  def load_task(task); end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_schedule.rb#14
  def load_tasks; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_schedule.rb#7
  def scheduled_tasks; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_schedule.rb#29
  def tasks; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_schedule.rb#24
  def unload_tasks; end

  private

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_schedule.rb#38
  def schedule(task); end
end

# source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#4
class SolidQueue::Dispatcher::RecurringTask
  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#17
  def initialize(key, class_name:, schedule:, arguments: T.unsafe(nil)); end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#15
  def arguments; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#15
  def class_name; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#24
  def delay_from_now; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#32
  def enqueue(at:); end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#15
  def key; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#28
  def next_time; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#15
  def schedule; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#54
  def to_h; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#50
  def to_s; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#46
  def valid?; end

  private

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#75
  def arguments_with_kwargs; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#87
  def job_class; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#83
  def parsed_schedule; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#71
  def perform_later; end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#67
  def perform_later_and_record(run_at:); end

  # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#63
  def using_solid_queue_adapter?; end

  class << self
    # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#10
    def from_configuration(key, **options); end

    # source://solid_queue//lib/solid_queue/dispatcher/recurring_task.rb#6
    def wrap(args); end
  end
end

# source://solid_queue//lib/solid_queue/engine.rb#4
class SolidQueue::Engine < ::Rails::Engine
  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end
  end
end

class SolidQueue::Execution < ::SolidQueue::Record
  include ::SolidQueue::Execution::GeneratedAttributeMethods
  include ::SolidQueue::Execution::GeneratedAssociationMethods
  include ::SolidQueue::Execution::JobAttributes
  extend ::SolidQueue::Execution::JobAttributes::ClassMethods

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_job(*args); end

  def discard; end
  def type; end

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activerecord/7.1.3.4/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    def assumable_attributes_from_job; end
    def assumable_attributes_from_job=(value); end
    def assumable_attributes_from_job?; end
    def create_all_from_jobs(jobs); end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    def discard_all_from_jobs(jobs); end
    def discard_all_in_batches(batch_size: T.unsafe(nil)); end
    def execution_data_from_jobs(jobs); end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def ordered(*args, **_arg1); end

    def type; end

    private

    def discard_jobs(job_ids); end
    def lock_all_from_jobs(jobs); end
  end
end

module SolidQueue::Execution::Dispatching
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Execution::Dispatching::ClassMethods
end

module SolidQueue::Execution::Dispatching::ClassMethods
  def dispatch_jobs(job_ids); end
end

module SolidQueue::Execution::GeneratedAssociationMethods
  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#32
  def build_job(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_job(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#40
  def create_job!(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def job; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def job=(value); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/belongs_to.rb#145
  def job_changed?; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/belongs_to.rb#149
  def job_previously_changed?; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_job; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#23
  def reset_job; end
end

module SolidQueue::Execution::GeneratedAttributeMethods; end

module SolidQueue::Execution::JobAttributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::SolidQueue::Execution::JobAttributes::ClassMethods

  private

  def assume_attributes_from_job; end

  module GeneratedClassMethods
    def assumable_attributes_from_job; end
    def assumable_attributes_from_job=(value); end
    def assumable_attributes_from_job?; end
  end

  module GeneratedInstanceMethods; end
end

module SolidQueue::Execution::JobAttributes::ClassMethods
  def assumes_attributes_from_job(*attribute_names); end
  def attributes_from_job(job); end
end

class SolidQueue::Execution::UndiscardableError < ::StandardError; end

class SolidQueue::FailedExecution < ::SolidQueue::Execution
  include ::SolidQueue::FailedExecution::GeneratedAttributeMethods
  include ::SolidQueue::FailedExecution::GeneratedAssociationMethods
  include ::SolidQueue::Execution::Dispatching
  extend ::SolidQueue::Execution::Dispatching::ClassMethods

  def backtrace; end
  def exception; end
  def exception=(_arg0); end
  def exception_class; end
  def message; end
  def retry; end

  private

  def expand_error_details_from_exception; end

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.3.4/lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads; end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    def retry_all(jobs); end
  end
end

module SolidQueue::FailedExecution::GeneratedAssociationMethods; end
module SolidQueue::FailedExecution::GeneratedAttributeMethods; end

class SolidQueue::Job < ::SolidQueue::Record
  include ::SolidQueue::Job::GeneratedAttributeMethods
  include ::SolidQueue::Job::GeneratedAssociationMethods
  include ::SolidQueue::Job::Recurrable
  include ::SolidQueue::Job::Clearable
  include ::SolidQueue::Job::Executable
  include ::SolidQueue::Job::Schedulable
  include ::SolidQueue::Job::ConcurrencyControls
  extend ::SolidQueue::Job::Clearable::ClassMethods
  extend ::SolidQueue::Job::Executable::ClassMethods
  extend ::SolidQueue::Job::Schedulable::ClassMethods
  extend ::SolidQueue::Job::ConcurrencyControls::ClassMethods

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_blocked_execution(*args); end

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_claimed_execution(*args); end

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_failed_execution(*args); end

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_ready_execution(*args); end

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_recurring_execution(*args); end

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_scheduled_execution(*args); end

  def concurrency_duration(*_arg0, **_arg1, &_arg2); end
  def concurrency_limit(*_arg0, **_arg1, &_arg2); end

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activerecord/7.1.3.4/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.3.4/lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads; end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def clearable(*args, **_arg1); end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    def enqueue(active_job, scheduled_at: T.unsafe(nil)); end
    def enqueue_all(active_jobs); end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def failed(*args, **_arg1); end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def finished(*args, **_arg1); end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def scheduled(*args, **_arg1); end

    private

    def attributes_from_active_job(active_job); end
    def create_all_from_active_jobs(active_jobs); end
    def create_from_active_job(active_job); end
  end
end

module SolidQueue::Job::Clearable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Job::Clearable::ClassMethods
end

module SolidQueue::Job::Clearable::ClassMethods
  def clear_finished_in_batches(batch_size: T.unsafe(nil), finished_before: T.unsafe(nil), class_name: T.unsafe(nil)); end
end

module SolidQueue::Job::ConcurrencyControls
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Job::ConcurrencyControls::ClassMethods

  def blocked?; end
  def concurrency_limited?; end
  def unblock_next_blocked_job; end

  private

  def acquire_concurrency_lock; end
  def block; end
  def execution; end
  def job_class; end
  def release_concurrency_lock; end
  def release_next_blocked_job; end
end

module SolidQueue::Job::ConcurrencyControls::ClassMethods
  def release_all_concurrency_locks(jobs); end
end

module SolidQueue::Job::Executable
  extend ::ActiveSupport::Concern

  def claimed?; end
  def discard; end
  def dispatch; end
  def dispatch_bypassing_concurrency_limits; end
  def failed?; end
  def failed_with(exception); end
  def finished!; end
  def finished?; end
  def prepare_for_execution; end
  def ready?; end
  def retry; end
  def status; end

  private

  def execution; end
  def ready; end
end

module SolidQueue::Job::Executable::ClassMethods
  def dispatch_all(jobs); end
  def prepare_all_for_execution(jobs); end

  private

  def dispatch_all_at_once(jobs); end
  def dispatch_all_one_by_one(jobs); end
  def dispatched_and_blocked(jobs); end
  def dispatched_and_ready(jobs); end
  def successfully_dispatched(jobs); end
end

module SolidQueue::Job::GeneratedAssociationMethods
  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def blocked_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def blocked_execution=(value); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#32
  def build_blocked_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#32
  def build_claimed_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#32
  def build_failed_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#32
  def build_ready_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#32
  def build_recurring_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#32
  def build_scheduled_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def claimed_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def claimed_execution=(value); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_blocked_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#40
  def create_blocked_execution!(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_claimed_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#40
  def create_claimed_execution!(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_failed_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#40
  def create_failed_execution!(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_ready_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#40
  def create_ready_execution!(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_recurring_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#40
  def create_recurring_execution!(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_scheduled_execution(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#40
  def create_scheduled_execution!(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def failed_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def failed_execution=(value); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def ready_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def ready_execution=(value); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def recurring_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def recurring_execution=(value); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_blocked_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_claimed_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_failed_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_ready_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_recurring_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_scheduled_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#23
  def reset_blocked_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#23
  def reset_claimed_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#23
  def reset_failed_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#23
  def reset_ready_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#23
  def reset_recurring_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#23
  def reset_scheduled_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def scheduled_execution; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def scheduled_execution=(value); end
end

module SolidQueue::Job::GeneratedAttributeMethods; end

module SolidQueue::Job::Recurrable
  extend ::ActiveSupport::Concern
end

module SolidQueue::Job::Schedulable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Job::Schedulable::ClassMethods

  def due?; end
  def scheduled?; end

  private

  def execution; end
  def schedule; end
end

module SolidQueue::Job::Schedulable::ClassMethods
  def schedule_all(jobs); end

  private

  def schedule_all_at_once(jobs); end
  def successfully_scheduled(jobs); end
end

# source://solid_queue//lib/solid_queue/log_subscriber.rb#5
class SolidQueue::LogSubscriber < ::ActiveSupport::LogSubscriber
  # source://solid_queue//lib/solid_queue/log_subscriber.rb#86
  def deregister_process(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#30
  def discard(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#26
  def discard_all(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#6
  def dispatch_scheduled(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#42
  def enqueue_recurring_task(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#113
  def graceful_termination(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#123
  def immediate_termination(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#105
  def prune_processes(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#75
  def register_process(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#38
  def release_blocked(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#14
  def release_claimed(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#34
  def release_many_blocked(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#10
  def release_many_claimed(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#131
  def replace_fork(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#22
  def retry(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#18
  def retry_all(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#64
  def shutdown_process(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#53
  def start_process(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#109
  def thread_error(event); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#127
  def unhandled_signal_error(event); end

  private

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#152
  def formatted_attributes(**attributes); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#156
  def formatted_error(error); end

  # source://solid_queue//lib/solid_queue/log_subscriber.rb#148
  def formatted_event(event, action:, **attributes); end

  # Use the logger configured for SolidQueue
  #
  # source://solid_queue//lib/solid_queue/log_subscriber.rb#161
  def logger; end
end

class SolidQueue::Pause < ::SolidQueue::Record
  include ::SolidQueue::Pause::GeneratedAttributeMethods
  include ::SolidQueue::Pause::GeneratedAssociationMethods

  class << self
    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end
  end
end

module SolidQueue::Pause::GeneratedAssociationMethods; end
module SolidQueue::Pause::GeneratedAttributeMethods; end

# source://solid_queue//lib/solid_queue/pool.rb#4
class SolidQueue::Pool
  include ::SolidQueue::AppExecutor

  # @return [Pool] a new instance of Pool
  #
  # source://solid_queue//lib/solid_queue/pool.rb#11
  def initialize(size, on_idle: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/pool.rb#41
  def idle?; end

  # source://solid_queue//lib/solid_queue/pool.rb#37
  def idle_threads; end

  # source://solid_queue//lib/solid_queue/pool.rb#18
  def post(execution); end

  # source://solid_queue//lib/solid_queue/pool.rb#9
  def shutdown(*_arg0, **_arg1, &_arg2); end

  # source://solid_queue//lib/solid_queue/pool.rb#9
  def shutdown?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute size.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#7
  def size; end

  # source://solid_queue//lib/solid_queue/pool.rb#9
  def wait_for_termination(*_arg0, **_arg1, &_arg2); end

  private

  # Returns the value of attribute available_threads.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#46
  def available_threads; end

  # source://solid_queue//lib/solid_queue/pool.rb#54
  def executor; end

  # Returns the value of attribute mutex.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#46
  def mutex; end

  # Returns the value of attribute on_idle.
  #
  # source://solid_queue//lib/solid_queue/pool.rb#46
  def on_idle; end
end

# source://solid_queue//lib/solid_queue/pool.rb#48
SolidQueue::Pool::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class SolidQueue::Process < ::SolidQueue::Record
  include ::SolidQueue::Process::GeneratedAttributeMethods
  include ::SolidQueue::Process::GeneratedAssociationMethods
  include ::SolidQueue::Process::Prunable
  extend ::SolidQueue::Process::Prunable::ClassMethods

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_claimed_executions(*args); end

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_forks(*args); end

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_supervisor(*args); end

  def deregister(pruned: T.unsafe(nil)); end
  def heartbeat; end

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_claimed_executions(*args); end

  # source://activerecord/7.1.3.4/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_forks(*args); end

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activerecord/7.1.3.4/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.3.4/lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads; end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def prunable(*args, **_arg1); end

    def register(**attributes); end
  end
end

module SolidQueue::Process::GeneratedAssociationMethods
  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#32
  def build_supervisor(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/collection_association.rb#62
  def claimed_execution_ids; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/collection_association.rb#72
  def claimed_execution_ids=(ids); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def claimed_executions; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def claimed_executions=(value); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#36
  def create_supervisor(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#40
  def create_supervisor!(*args, &block); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/collection_association.rb#62
  def fork_ids; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/collection_association.rb#72
  def fork_ids=(ids); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def forks; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def forks=(value); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#19
  def reload_supervisor; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/singular_association.rb#23
  def reset_supervisor; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#103
  def supervisor; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/association.rb#111
  def supervisor=(value); end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/belongs_to.rb#145
  def supervisor_changed?; end

  # source://activerecord/7.1.3.4/lib/active_record/associations/builder/belongs_to.rb#149
  def supervisor_previously_changed?; end
end

module SolidQueue::Process::GeneratedAttributeMethods; end

module SolidQueue::Process::Prunable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::SolidQueue::Process::Prunable::ClassMethods
end

module SolidQueue::Process::Prunable::ClassMethods
  def prune; end
end

# source://solid_queue//lib/solid_queue/dispatcher.rb#0
module SolidQueue::Processes; end

# source://solid_queue//lib/solid_queue/processes/base.rb#5
class SolidQueue::Processes::Base
  include ::SolidQueue::Processes::Callbacks
  include ::ActiveSupport::Callbacks
  include ::SolidQueue::Processes::Procline
  include ::SolidQueue::Processes::Interruptible
  include ::SolidQueue::Processes::Registrable
  include ::SolidQueue::AppExecutor
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#963
  def _boot_callbacks; end

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#951
  def _run_boot_callbacks(&block); end

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#951
  def _run_shutdown_callbacks(&block); end

  # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#963
  def _shutdown_callbacks; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#13
  def hostname; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#9
  def kind; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#21
  def metadata; end

  # source://solid_queue//lib/solid_queue/processes/base.rb#17
  def pid; end

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#955
    def _boot_callbacks; end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#959
    def _boot_callbacks=(value); end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#955
    def _shutdown_callbacks; end

    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#959
    def _shutdown_callbacks=(value); end

    # source://activemodel/7.1.3.4/lib/active_model/callbacks.rb#144
    def after_boot(*args, **options, &block); end

    # source://activemodel/7.1.3.4/lib/active_model/callbacks.rb#144
    def after_shutdown(*args, **options, &block); end

    # source://activemodel/7.1.3.4/lib/active_model/callbacks.rb#137
    def around_boot(*args, **options, &block); end

    # source://activemodel/7.1.3.4/lib/active_model/callbacks.rb#137
    def around_shutdown(*args, **options, &block); end

    # source://activemodel/7.1.3.4/lib/active_model/callbacks.rb#130
    def before_boot(*args, **options, &block); end

    # source://activemodel/7.1.3.4/lib/active_model/callbacks.rb#130
    def before_shutdown(*args, **options, &block); end
  end
end

# source://solid_queue//lib/solid_queue/processes/callbacks.rb#4
module SolidQueue::Processes::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker

  private

  # source://solid_queue//lib/solid_queue/processes/callbacks.rb#13
  def boot; end

  # source://solid_queue//lib/solid_queue/processes/callbacks.rb#16
  def shutdown; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

# source://solid_queue//lib/solid_queue/processes/signals.rb#4
class SolidQueue::Processes::GracefulTerminationRequested < ::Interrupt; end

# source://solid_queue//lib/solid_queue/processes/signals.rb#5
class SolidQueue::Processes::ImmediateTerminationRequested < ::Interrupt; end

# source://solid_queue//lib/solid_queue/processes/interruptible.rb#4
module SolidQueue::Processes::Interruptible
  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#5
  def wake_up; end

  private

  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#32
  def create_self_pipe; end

  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#12
  def interrupt; end

  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#20
  def interruptible_sleep(time); end

  # Self-pipe for signal-handling (http://cr.yp.to/docs/selfpipe.html)
  #
  # source://solid_queue//lib/solid_queue/processes/interruptible.rb#28
  def self_pipe; end
end

# source://solid_queue//lib/solid_queue/processes/interruptible.rb#10
SolidQueue::Processes::Interruptible::SELF_PIPE_BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://solid_queue//lib/solid_queue/processes/pidfile.rb#4
class SolidQueue::Processes::Pidfile
  # @return [Pidfile] a new instance of Pidfile
  #
  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#5
  def initialize(path); end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#16
  def delete; end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#10
  def setup; end

  private

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#54
  def already_running!; end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#23
  def check_status; end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#50
  def delete_file; end

  # Returns the value of attribute path.
  #
  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#21
  def path; end

  # Returns the value of attribute pid.
  #
  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#21
  def pid; end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#46
  def set_at_exit_hook; end

  # source://solid_queue//lib/solid_queue/processes/pidfile.rb#39
  def write_file; end
end

# source://solid_queue//lib/solid_queue/processes/poller.rb#4
module SolidQueue::Processes::Poller
  include ::SolidQueue::Processes::Supervised
  include ::SolidQueue::Processes::Runnable
  extend ::ActiveSupport::Concern

  # source://solid_queue//lib/solid_queue/processes/poller.rb#13
  def metadata; end

  private

  # @raise [NotImplementedError]
  #
  # source://solid_queue//lib/solid_queue/processes/poller.rb#42
  def poll; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#18
  def run; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#26
  def start_loop; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#46
  def with_polling_volume; end
end

# source://solid_queue//lib/solid_queue/processes/procline.rb#4
module SolidQueue::Processes::Procline
  # Sets the procline ($0)
  # solid-queue-supervisor(0.1.0): <string>
  #
  # source://solid_queue//lib/solid_queue/processes/procline.rb#7
  def procline(string); end
end

# source://solid_queue//lib/solid_queue/processes/registrable.rb#4
module SolidQueue::Processes::Registrable
  extend ::ActiveSupport::Concern

  private

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#26
  def deregister; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#46
  def heartbeat; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#34
  def launch_heartbeat; end

  # Returns the value of attribute process.
  #
  # source://solid_queue//lib/solid_queue/processes/registrable.rb#15
  def process; end

  # Sets the attribute process
  #
  # @param value the value to set the attribute process to.
  #
  # source://solid_queue//lib/solid_queue/processes/registrable.rb#15
  def process=(_arg0); end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#17
  def register; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/registrable.rb#30
  def registered?; end

  # source://solid_queue//lib/solid_queue/processes/registrable.rb#42
  def stop_heartbeat; end
end

# source://solid_queue//lib/solid_queue/processes/runnable.rb#4
module SolidQueue::Processes::Runnable
  include ::SolidQueue::Processes::Supervised

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#7
  def mode=(_arg0); end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#9
  def start; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#19
  def stop; end

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#8
  def supervisor; end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#54
  def all_work_completed?; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#31
  def boot; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#50
  def finished?; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#27
  def mode; end

  # @raise [NotImplementedError]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#42
  def run; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#61
  def running_inline?; end

  # source://solid_queue//lib/solid_queue/processes/runnable.rb#58
  def set_procline; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#38
  def shutting_down?; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/runnable.rb#46
  def stopping?; end
end

# source://solid_queue//lib/solid_queue/processes/runnable.rb#25
SolidQueue::Processes::Runnable::DEFAULT_MODE = T.let(T.unsafe(nil), Symbol)

# source://solid_queue//lib/solid_queue/processes/signals.rb#7
module SolidQueue::Processes::Signals
  extend ::ActiveSupport::Concern

  private

  # source://solid_queue//lib/solid_queue/processes/signals.rb#34
  def handle_signal(signal); end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#28
  def process_signal_queue; end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#13
  def register_signal_handlers; end

  # @raise [GracefulTerminationRequested]
  #
  # source://solid_queue//lib/solid_queue/processes/signals.rb#45
  def request_graceful_termination; end

  # @raise [ImmediateTerminationRequested]
  #
  # source://solid_queue//lib/solid_queue/processes/signals.rb#49
  def request_immediate_termination; end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#22
  def restore_default_signal_handlers; end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#59
  def signal_process(pid, signal); end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#53
  def signal_processes(pids, signal); end

  # source://solid_queue//lib/solid_queue/processes/signals.rb#65
  def signal_queue; end
end

# source://solid_queue//lib/solid_queue/processes/signals.rb#11
SolidQueue::Processes::Signals::SIGNALS = T.let(T.unsafe(nil), Array)

# source://solid_queue//lib/solid_queue/processes/supervised.rb#4
module SolidQueue::Processes::Supervised
  extend ::ActiveSupport::Concern

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#11
  def supervised_by(process); end

  private

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#29
  def register_signal_handlers; end

  # source://solid_queue//lib/solid_queue/processes/supervised.rb#17
  def set_procline; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/supervised.rb#25
  def supervised?; end

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/processes/supervised.rb#21
  def supervisor_went_away?; end
end

class SolidQueue::Queue
  def initialize(name); end

  def ==(queue); end
  def clear; end
  def eql?(queue); end
  def hash; end
  def name; end
  def name=(_arg0); end
  def pause; end
  def paused?; end
  def resume; end
  def size; end

  class << self
    def all; end
    def find_by_name(name); end
  end
end

class SolidQueue::QueueSelector
  def initialize(queue_list, relation); end

  def raw_queues; end
  def relation; end
  def scoped_relations; end

  private

  def all?; end
  def all_queues; end
  def eligible_queues; end
  def exact_names; end
  def include_all_queues?; end
  def none?; end
  def paused_queues; end
  def prefixed_names; end
  def prefixes; end
  def queue_names; end
end

class SolidQueue::ReadyExecution < ::SolidQueue::Execution
  include ::SolidQueue::ReadyExecution::GeneratedAttributeMethods
  include ::SolidQueue::ReadyExecution::GeneratedAssociationMethods

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    def aggregated_count_across(queue_list); end
    def assumable_attributes_from_job; end
    def claim(queue_list, limit, process_id); end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def queued_as(*args, **_arg1); end

    private

    def discard_jobs(job_ids); end
    def lock_candidates(job_ids, process_id); end
    def select_and_lock(queue_relation, process_id, limit); end
    def select_candidates(queue_relation, limit); end
  end
end

module SolidQueue::ReadyExecution::GeneratedAssociationMethods; end
module SolidQueue::ReadyExecution::GeneratedAttributeMethods; end

class SolidQueue::Record < ::ActiveRecord::Base
  include ::SolidQueue::Record::GeneratedAttributeMethods
  include ::SolidQueue::Record::GeneratedAssociationMethods

  class << self
    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    def non_blocking_lock; end
  end
end

module SolidQueue::Record::GeneratedAssociationMethods; end
module SolidQueue::Record::GeneratedAttributeMethods; end

class SolidQueue::RecurringExecution < ::SolidQueue::Execution
  include ::SolidQueue::RecurringExecution::GeneratedAttributeMethods
  include ::SolidQueue::RecurringExecution::GeneratedAssociationMethods

  class << self
    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    def clear_in_batches(batch_size: T.unsafe(nil)); end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def clearable(*args, **_arg1); end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    def record(task_key, run_at, &block); end
  end
end

module SolidQueue::RecurringExecution::GeneratedAssociationMethods; end
module SolidQueue::RecurringExecution::GeneratedAttributeMethods; end

class SolidQueue::ScheduledExecution < ::SolidQueue::Execution
  include ::SolidQueue::ScheduledExecution::GeneratedAttributeMethods
  include ::SolidQueue::ScheduledExecution::GeneratedAssociationMethods
  include ::SolidQueue::Execution::Dispatching
  extend ::SolidQueue::Execution::Dispatching::ClassMethods

  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    def assumable_attributes_from_job; end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    def dispatch_next_batch(batch_size); end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def due(*args, **_arg1); end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def next_batch(*args, **_arg1); end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def ordered(*args, **_arg1); end
  end
end

module SolidQueue::ScheduledExecution::GeneratedAssociationMethods; end
module SolidQueue::ScheduledExecution::GeneratedAttributeMethods; end

class SolidQueue::Semaphore < ::SolidQueue::Record
  include ::SolidQueue::Semaphore::GeneratedAttributeMethods
  include ::SolidQueue::Semaphore::GeneratedAssociationMethods

  class << self
    # source://activemodel/7.1.3.4/lib/active_model/validations.rb#71
    def _validators; end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def available(*args, **_arg1); end

    # source://activerecord/7.1.3.4/lib/active_record/enum.rb#167
    def defined_enums; end

    # source://activerecord/7.1.3.4/lib/active_record/scoping/named.rb#174
    def expired(*args, **_arg1); end

    def signal(job); end
    def signal_all(jobs); end
    def wait(job); end
  end
end

module SolidQueue::Semaphore::GeneratedAssociationMethods; end
module SolidQueue::Semaphore::GeneratedAttributeMethods; end

class SolidQueue::Semaphore::Proxy
  def initialize(job); end

  def signal; end
  def wait; end

  private

  def attempt_creation; end
  def attempt_decrement; end
  def attempt_increment; end
  def expires_at; end
  def job; end
  def job=(_arg0); end
  def key; end
  def limit; end

  class << self
    def signal_all(jobs); end
  end
end

# source://solid_queue//lib/solid_queue/supervisor.rb#4
class SolidQueue::Supervisor < ::SolidQueue::Processes::Base
  include ::SolidQueue::Processes::Signals

  # @return [Supervisor] a new instance of Supervisor
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#16
  def initialize(*configured_processes); end

  # source://solid_queue//lib/solid_queue/supervisor.rb#21
  def start; end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#159
  def all_forks_terminated?; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#38
  def boot; end

  # Returns the value of attribute configured_processes.
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#36
  def configured_processes; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#112
  def delete_pidfile; end

  # Returns the value of attribute forks.
  #
  # source://solid_queue//lib/solid_queue/supervisor.rb#36
  def forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#79
  def graceful_termination; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#94
  def immediate_termination; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#68
  def launch_process_prune; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#179
  def monotonic_time_now; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#116
  def prune_dead_processes; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#104
  def quit_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#130
  def reap_and_replace_terminated_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#139
  def reap_terminated_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#150
  def replace_fork(pid, status); end

  # source://solid_queue//lib/solid_queue/supervisor.rb#58
  def setup_pidfile; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#73
  def shutdown; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#120
  def start_fork(configured_process); end

  # source://solid_queue//lib/solid_queue/supervisor.rb#64
  def start_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#108
  def stop_process_prune; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#44
  def supervise; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#54
  def sync_std_streams; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#100
  def term_forks; end

  # source://solid_queue//lib/solid_queue/supervisor.rb#163
  def wait_until(timeout, condition, &block); end

  class << self
    # source://solid_queue//lib/solid_queue/supervisor.rb#8
    def start(mode: T.unsafe(nil), load_configuration_from: T.unsafe(nil)); end
  end
end

# source://solid_queue//lib/solid_queue/version.rb#2
SolidQueue::VERSION = T.let(T.unsafe(nil), String)

# source://solid_queue//lib/solid_queue/worker.rb#4
class SolidQueue::Worker < ::SolidQueue::Processes::Base
  include ::SolidQueue::Processes::Supervised
  include ::SolidQueue::Processes::Runnable
  include ::SolidQueue::Processes::Poller

  # @return [Worker] a new instance of Worker
  #
  # source://solid_queue//lib/solid_queue/worker.rb#9
  def initialize(**options); end

  # source://solid_queue//lib/solid_queue/worker.rb#17
  def metadata; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#10
  def polling_interval; end

  # source://solid_queue//lib/solid_queue/processes/poller.rb#10
  def polling_interval=(_arg0); end

  # Returns the value of attribute pool.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#7
  def pool; end

  # Sets the attribute pool
  #
  # @param value the value to set the attribute pool to.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#7
  def pool=(_arg0); end

  # Returns the value of attribute queues.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#7
  def queues; end

  # Sets the attribute queues
  #
  # @param value the value to set the attribute queues to.
  #
  # source://solid_queue//lib/solid_queue/worker.rb#7
  def queues=(_arg0); end

  private

  # @return [Boolean]
  #
  # source://solid_queue//lib/solid_queue/worker.rb#45
  def all_work_completed?; end

  # source://solid_queue//lib/solid_queue/worker.rb#32
  def claim_executions; end

  # source://solid_queue//lib/solid_queue/worker.rb#22
  def poll; end

  # source://solid_queue//lib/solid_queue/worker.rb#49
  def set_procline; end

  # source://solid_queue//lib/solid_queue/worker.rb#38
  def shutdown; end
end
